\chapter{Entwicklung}
Um das Serverless Konzept mit seinen Vor- und Nachteil
besser zu verdeutlichen, wird eine prototypische Anwendung nach den Serverless-Prinzipien
entwickelt. Dieses Kapitel beinhaltet die Architektur und Implementierung
der Anwendung. Davor werden Dienste und Werkzeuge vorgestellt,
die für die Realisierung verwendet wurden.

Es soll den Korrektoren und Studenten des Moduls
Programmierung der Heinrich-Heine-Universität
möglich sein einfache Java Programme in einer einheitlichen und isolierten Umgebung
auszuführen und zu testen.
Studenten können dadurch ihre Aufgaben vor der Abgabe testen, um sicherzugehen,
dass sie auch bei der Korrektur wie gewollt laufen.
Korrektoren müssen sich keine Gedanken um die Sicherheit ihrer Systeme
machen. Sie brauchen keine aufwändigen VMs starten, denn die Aufgaben werden
bereits in einer abgesicherten Umgebung ausgeführt.

Die serverlose Anwendung ermöglicht es einzelne Java Dateien auszuführen.
Werden zusätzliche JUnit Testdateien mitgeliefert,
können auch diese gestartet werden. Das Resultat der Tests wird wieder
zurückgeliefert.
Da die Aufgaben des Moduls Gradle benutzen,
können auch Gradle-Projekte ausgeführt und getestet werden.
Jedoch wird dafür das Applikation-Plugin\footnote{\url{https://docs.gradle.org/current/userguide/application_plugin.html}}
vorausgesetzt, sodass die Aufgaben des Moduls leicht angepasst werden müssen.
Die Anwendung kann vollständig durch die Kommandozeile angesprochen werden, denn
sie stellt eine REST-API bereit.
Jedoch wird auch ein Endpunkt zur Verfügung gestellt, der eine Webseite zurückliefert.
Das Layout der Seite richtet sich grob nach dem Styleguide der
Modularen Online Platform für Studierende (MOPS)\footnote{\url{https://mops.style}}
der HHU. In ihr wird das Frontend eingebunden.
Es kann von den Studenten als Entwicklungsumgebung benutzt werden, um
ihre Java-Projekte zu entwickeln und anschließend zu testen.
Jedoch liegt der Fokus der Arbeit auf der serverlosen Backend-Anwendung.


\section{Dienste und Tools}
\paragraph{Serverloser Dienst} Bei dem serverlosen Dienst wird auf Google Cloud Run zurückgegriffen.
Es bietet mehr Freiheit als FaaS Dienste der Cloud-Provider an, da mittels Dockerfile die Laufzeitumgebung
der Anwendung genaustens definiert und konfiguriert werden kann. Auch Open-Source
Plattformen wurden in Erwägung gezogen, jedoch aufgrund der etwas komplexeren Bereitstellung nicht ausgewählt.
Da die Anwendung für Studenten und Korrektoren
des Moduls Programmierung ausgelegt ist und der Datenschutz für Universitäten eine wichtige Rolle
spielt, wird der Punkt in \autoref{chap:conclusion_and_outlook} noch einmal aufgegriffen.

\paragraph{Webserver} Die Anwendung selbst wird mit dem Web-Framework
Flask\footnote{\url{https://palletsprojects.com/p/flask/}}
entwickelt. Als Programmiersprache wird Python verwendet.
Flask ermöglicht die schnelle und unkomplizierte Bereitstellung einer REST-API.
Da MOPS auf Spring Boot\footnote{\url{https://spring.io/projects/spring-boot}} basiert und
der Styleguide die Template-Engine Thymeleaf verwendet, welche in Flask nicht unterstützt wird,
richtet sich die Anwendung nur an dem Styleguide und implementiert es nicht vollständig.

\paragraph{Frontend Web-Framework} Für die grafische Entwicklungsumgebung
wird mit Vue.js\footnote{\url{https://vuejs.org}} ebenfalls ein Web-Framework verwendet.
Das Frontend wird in der Programmiersprache JavaScript geschrieben. Es dient als
erweiterte Funktionalität und gehört nicht zum Kern der in dieser Arbeit entwickelten
serverlosen Anwendung. Jedoch bietet sie eine bequemere Interaktion mit der Anwendung als
die Kommandozeile. Das Frontend wird mit
Firebase Hosting\footnote{\url{https://firebase.google.com/docs/hosting}}, einem weiteren Google Dienst,
bereitgestellt. Bei Firebase Hosting kann das sichere Hosten von statischen Webseiten
mit wenigen Befehlen bewältigt werden.

\section{Architektur}
Die Architektur in Abbildung~\ref{fig:architecture} besteht auf zwei
Komponenten.
Die Cloud Run Container Instanzen bilden das serverlose Backend.
Eine Instanz stellt Endpunkte bereit die mit
HTTP-Anfragen\footnote{\url{https://tools.ietf.org/html/rfc2616}}
angesprochen werden können. Rufen Benutzer
mittels einer HTTP-GET Anfrage den
Root-Endpunkt auf \textbf{(1)} so wird
die \texttt{index.html} Datei zurückgesendet \textbf{(2)}.
Sie enthält die grafische Benutzeroberfläche. Das Layout richtet
sich an dem Styleguide des MOPS. Durch ein
HTML-iframe Element\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe}}
wird das eigentliche Frontend eingebunden. Das Frontend dient als Entwicklungsumgebung für
Studenten, um ihre Programme zu entwickeln. Die Aufteilung von Frontend und Backend
ermöglicht eine einfache Verwaltung und Erweiterung beider Komponenten.
Durch Interaktion mit der Entwicklungsumgebung \textbf{(3)} lassen sich einige
der restlichen Endpunkte \textbf{(4)} aufrufen. 
Da das Backend eine REST-API bereitstellt, ist auch ein direkter Zugriff \textbf{(5)} auf alle 
Endpunkte über die Kommandozeile und HTTP-POST Anfragen möglich.

\begin{figure}
  \centering
  \includegraphics[height=10cm]{fig/architecture.pdf}
  \caption{Architektur und Interaktion der Anwendung}
  \label{fig:architecture}
\end{figure}

\section{Serverless Backend}
Das Backend wird durch Endpunkte angesprochen.
Der Java Quellcode kann mittels HTTP-POST Anfrage an das
Backend gesendet werden und wird dort durch das Java Development Kit
beziehungsweise Gradle ausgeführt oder getestet.


\paragraph{Java Development Kit} Für das Kompilieren und
anschließende Ausführen der Java Dateien wird
Zulu OpenJDK 11 benutzt, da die Installation auf
Alpine Linux-Betriebssystemen\footnote{\url{https://alpinelinux.org}}
verständlich dokumentiert ist \cite{AzulZuluJDK}.
Das JDK stellt die zwei Befehle \texttt{javac} und \texttt{java} bereit.
Übergeben Studenten oder Korrektoren ihren Java Quellcode mittels HTTP-POST Anfrage an
das Backend, so muss es in der Lage sein, den Befehl \texttt{javac}
aufzurufen. Denn dadurch können die Java Dateien kompiliert werden.
Nach der erfolgreichen Kompilation können durch den \texttt{java} Befehl die kompilierten Dateien
ausgeführt werden. Um dem Backend dies zu Ermöglichen muss das JDK in die Laufzeitumgebung eingepackt
werden, damit die Anwendung während ihrer Ausführung die zwei Befehle aufrufen kann.\\

\begin{lstlisting}[caption={Ausschnitt aus der Dockerfile. Herunterladen und Einrichten des JDK.}, label={lst:dockerfile}, escapechar=|]
# Install Zulu11
RUN apk --no-cache add zulu11-jdk-headless |\label{line:installJDK}|
ENV JAVA_HOME=/usr/lib/jvm/default-jvm |\label{line:javaHome}|
ENV PATH="$JAVA_HOME/bin:${PATH}" |\label{line:javaPath}|

# Check if two commands are available
RUN which javac |\label{line:testJavac}|
RUN which java |\label{line:testJava}|
\end{lstlisting}

In Auflistung~\ref{lst:dockerfile} ist ein Ausschnitt
aus der Dockerfile zusehen, welche die Laufzeitumgebung
der Cloud Run Container Instanzen definiert. Das JDK wird
heruntergeladen und installiert \textbf{(Zeile~\ref{line:installJDK})}.
Außerdem werden wichtige Umgebungsvariablen
gesetzt \textbf{(Zeile~\ref{line:javaHome},~\ref{line:javaPath})}.
Abschließend wird geprüft ob die beiden Befehle
zur Verfügung stehen \textbf{(Zeile~\ref{line:testJavac},~\ref{line:testJava})}.

\paragraph{Gradle} Um ein Gradle-Projekte auszuführen und
zu testen, gibt es unter anderem zwei Möglichkeiten.
Einem Gradle-Projekt kann der Gradle-Wrapper (Wrapper)
beigelegt sein. Dieser definiert welche Version von Gradle benutzt
werden soll und lädt sich Gradle für das Bauen des Projekts selbstständig herunter.
Normalerweise ist es empfohlen den Wrapper zu benutzen,
da dieser das Bauen des Projektes standardisiert und
somit weniger Fehler entstehen \cite{GradleWrapper}.
Jedoch hat sich beim ersten Ansatz der Implementierung herausgestellt, dass der
Wrapper für das serverlose Backend etwas ungünstig ist.
Bei einer Anfrage, in der eine neue Cloud Run Container Instanz
gestartet wird, verschwendet das Herunterladen von Gradle
unnötig Zeit und Rechenressourcen, denn die verbrauchte Zeit und der Rechenaufwand
werden bei serverlosen Diensten in Zahlung gestellt \cite{ServerlessTrends}.
Zusätzlich müssen Studenten und Korrektoren warten bis die Anwendung mit dem eigentlichen
Ausführen und Testen des Gradle-Projekts weitermacht.
Eine bessere Lösung ist Gradle in die Laufzeitumgebung einzubinden.
Wie in Auflistung~\ref{lst:gradle} zu sehen reicht es aus Gradle herunterzuladen
\textbf{(Zeile~\ref{line:downloadGradle})}
und zu entpacken \textbf{(Zeile~\ref{line:unzipGradle})}.
Dadurch muss Gradle nicht immer wieder heruntergeladen werden.
Die Anwendung braucht nur noch den \texttt{gradle test} oder \texttt{gradle run} Befehl
aufrufen und das Gradle-Projekt kann getestet oder ausgeführt werden \cite{GradleCLI}.\\

\begin{lstlisting}[caption={Ausschnitt aus der Dockerfile. Herunterladen und Entpacken von Gradle.}, label={lst:gradle}, escapechar=|]
# Get Gradle distribution zip
RUN wget https://downloads.gradle-dn.com/distributions/gradle-6.3-bin.zip |\label{line:downloadGradle}|
RUN unzip gradle-6.3-bin.zip |\label{line:unzipGradle}|
\end{lstlisting}

\subsection{Endpunkte}
Die Endpunkte sind mit \texttt{/run} sowie
\texttt{/test} in zwei Gruppen eingeteilt.
Die erste Gruppe ist für das Kompilieren und anschließende
Ausführen von Java Quellcode zuständig. Die zweite Gruppe ist
für das Ausführen von JUnit-Tests verantwortlich. Die Anwendung
sendet als Antwort ein JSON-Objekt zurück, welche das Resultat
der Ausführung oder der Tests beinhaltet.

\paragraph{/run/java Endpunkt} Ein beispielhafter Aufruf des
Endpunktes mit curl\footnote{\url{https://curl.haxx.se}} ist in
Auflistung~\ref{lst:curlRunJava} dargestellt.
Die einzelnen Java Dateien werden im
Entity-Body\footnote{\url{https://tools.ietf.org/html/rfc2616\#section-7.2}}
der Anfrage mitgeliefert
\textbf{(Zeile~\ref{line:javaFile1},~\ref{line:javaFile2})}.
Zusätzlich muss der Name der Klasse
angegeben werden, in der die Hauptmethode definiert ist
\textbf{(Zeile~\ref{line:mainClass})}.
Dieser Endpunkt soll den Studenten ermöglichen ihren Quellcode
schnell und unkompliziert auszuführen.\\

\begin{lstlisting}[
  caption={HTTP-POST Anfrage an /run/java um einzelne Java Dateien zu kompilieren und auszuführen.},
  label={lst:curlRunJava},
  escapechar=|
]
curl -F main_file=MyMainClass \ |\label{line:mainClass}|
  -F file=@MyMainClass.java \ |\label{line:javaFile1}|
  -F file=@Calculator.java \ |\label{line:javaFile2}|
  https://ba-serverless-testing-t6e6p4w6oa-ew.a.run.app/run/java
\end{lstlisting}

\paragraph{/run/gradle Endpunkt} Um eine Gradle-Projekt auszuführen
ist es nötigt das Projekt vorher in ein Zip-Archiv zu komprimieren.
Erst dann kann es ähnlich wie in Auflistung~\ref{lst:curlRunGradle}
an das Backend versendet werden.\\

\begin{lstlisting}[
  caption={HTTP-POST Anfrage an /run/gradle um ein Gradle-Projekt auszuführen.},
  label={lst:curlRunGradle},
  escapechar=|
]
curl -F file=@gradle_project.zip \
  https://ba-serverless-testing-t6e6p4w6oa-ew.a.run.app/run/gradle
\end{lstlisting}

At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet,
consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et
dolore magna aliquyam erat, sed diam voluptua.
At vero eos et accusam et justo duo dolores et ea rebum.
Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

\section{Frontend}
At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet,
consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et
dolore magna aliquyam erat, sed diam voluptua.
At vero eos et accusam et justo duo dolores et ea rebum.
Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
